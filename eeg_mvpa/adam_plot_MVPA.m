function map = adam_plot_MVPA(cfg,varargin)
% ADAM_PLOT_MVPA generates plots of group-level classification/ERP analyses, using as input the
% stats structure generated by adam_compute_group_MVPA, adam_compute_group_ERP, or
% adam_compare_MVPA_stats. Statistical outcomes in two-dimensional line plots are marked/outlined
% with a thick line on the graph itself and/or with a line close to the time axis (see
% plotsigline_method method below). For three-dimensional color graphs the uncorrected statistically
% significant values are saturated, while the non-significant points are desaturated. The FDR or
% cluster-based corrected values are encircled by a dark-red contour line (for above-chance
% decoding) or dark-blue contour line (for below chance decoding). Options exist to plot  multiple
% conditions in one figure (in case of line plots) or in multiple subplots. By default, for
% time-time or time-frequency maps, a blue-to-red colormap is used (instead of Matlab's default
% 'jet' or 'parula').
%
% Use as:
%   adam_plot_MVPA(cfg, stats1, stats2, ...);
%
% Inputs: 
%   cfg                       = contains input parameters to specify plotting (see below)
%   stats1, stats2, ...       = contains one or more stats variables computed by
%                               adam_compute_group_MVPA, adam_compute_group_ERP, etc. Function
%                               assumes that stats are based on the same accuracy measure and use
%                               the same statistical test.
%
% The cfg (configuration) input structure can contain the following:
%
%   cfg.singleplot            = false (default); if stats is an array containing multiple
%                               analyses/comparisons, false will generate a separate subplot for
%                               each analysis; true will plot all comparisons in a single plot (only
%                               possible for line plots, so with reduce_dims set to 'diag',
%                               'avtrain', or 'avtest' in adam_compute_group_MVPA, or for ERPs
%                               computed with adam_compute_group_ERP. By default, pre-defined colors
%                               are picked for each line. 
%   cfg.plot_order           =  {} (default), cell array of strings that specify in
%                               which order to plot the analyses, which either impacts the order of
%                               the subplots and/or the colors that are used in line plots. Define
%                               as e.g. cfg.plot_order = {'face_vs_house','house_vs_hand'}; to first
%                               plot 'face_vs_house' and then 'house_vs_hand'. Note that the strings
%                               you specify need to correspond exactly to the name specified in the
%                               stats.condname field, which corresponds to the folder name of the
%                               first level analyses that was used to create the stats variable.
%                               When specifying cfg.plot_order, analyses that are not listed are not
%                               plotted. 
%   cfg.acclim3D              = [int int]; min max of the color scaling reflecting accuracy in
%                               time-time and time-frequency color plots; default will choose a
%                               min/max automatically.
%   cfg.acclim2D              = [int int]; same as 3D, but for y-axis in line plots.
%   cfg.acclim                = [int int]; works for line plots and color plots. Overrides acclim3D
%                               and acclim2D.
%   cfg.cent_acctick          = [] (default); or int; the chance-level accuracy level will get a 
%                               tickmark; by default, chance-level is determined by
%                               1/stats.settings.nconds where nconds corresponds to the number of
%                               classes on which decoding was performed.
%   cfg.splinefreq            = [] (default); or int; for line plots, you can choose a spline
%                               frequency for smoothing (note: statistics are done on the RAW
%                               classification results). For example, when specifying cfg.splinfreq
%                               = 30, the resulting graph will be smoothed to a line that has
%                               the characteristics of a 30 Hz low-pass filtered signal.
%   cfg.timetick              = [] (default); or int; specifying the interval in ms between x-axis 
%                               tick marks (line plots) or x/y-axis ticks (time-time plots)
%   cfg.freqtick              = [] (default); or int; as in timetick, for frequency y-axis in case
%                               of time-frequency plot.
%   cfg.referenceline         = [int] in ms; you can plot a reference line
%                               e.g. if the stimulus-class triggers were sent at 100 ms, define
%                               cfg.referenceline = 100; You can also plot a series of reference
%                               lines by specifying the times as an array, e.g. 
%                               cfg.referenceline = [100, 200, 300, 400];
%   cfg.line_colors           = [] (default); or string cell array containing RGB triplets, e.g. 
%                               {[R G B],[R G B]} with integers between [0 1] for RGB values; this
%                               overrides the default colors for line plots.
%   cfg.swapaxes              = true (default); in a previous version of ADAM, training time was
%                               plotted on the x-axis and testing time on the y-axis for time-time
%                               plots, this is now swapped by default, but setting this to false
%                               will plot testing on y and training x.
%   cfg.inverty               = [] (default, for ERP plots default is true); you can choose to plot
%                               the voltage on the y-axis of ERP plots downward by setting to false.
%   cfg.plotsigline_method    = 'both' (default); Alternatively specify 'straight' a straight
%                               horizontal line at the bottom of the plot for (clusters of)
%                               significant time points. 'follow' will make the significant lines
%                               thicker in the graph itself. The default option 'both' will also
%                               make the line of the line plot thicker on these time points.
%   cfg.nolatency             = false (default); or true. If true, no latency onset of the first 
%                               component will be plotted.
%   cfg.plot_model            = 'BDM' (default); or 'FEM' if stats contains classification results
%                               of a forward encoding model.
%   cfg.figure_size           = [500 400] (default), to change the size of the figure on the screen
%                               (in pixels)
%   cfg.fh                    = figure handle, in case you want to plot to a specific figure that
%                               already has a window (handle) associated with it. E.g. create a
%                               figure handle using fh = figure; and subsequently plot using 
%                               cfg.fh = fh.
%
%
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%
% Example usage: 
% --> Plot two stats variables with smoothed lines in a single plot, with customized colors:
% cfg = [];
% cfg.singleplot  = true;
% cfg.splinefreq  = 30;
% cfg.line_colors = {[.2 .7 .3], [.9 .1 .1], [.5 .5 .5]};
% adam_plot_MVPA(cfg,stats,diffstats)
%
% part of the ADAM toolbox, by J.J.Fahrenfort, VU, 2017/2018
% 
% See also ADAM_COMPUTE_GROUP_ERP, ADAM_COMPUTE_GROUP_MVPA, ADAM_MVPA_FIRSTLEVEL,
% ADAM_PLOT_BDM_WEIGHTS, ADAM_COMPARE_MVPA_STATS


if nargin<2
    disp('cannot plot graph without stats input, need at least 2 arguments:');
    help adam_plot_MVPA;
    return
end

% concatenate stats
stats = concat_stats(varargin{:});

% settting some defaults
ploterp = false;
plot_model = 'BDM';
ndec = 2;
inverty = [];
plotsubjects = false;
singleplot = false;
plot_order = [];
figure_axis = 'horizontal';
folder = '';
startdir = '';
if strcmpi(stats(1).settings.dimord, 'freq_time')
    swapaxes = false;
else
    swapaxes = true;
end
referenceline = [];   % you can plot a reference line by indicating cfg.referenceline = timepoint (in milliseconds) where it should be plotted.
if numel(stats) > 1
    line_colors = {[.5 0 0] [0 .5 0] [0 0 .5] [.5 .5 0] [0 .5 .5] [.5 0 .5] [.75 0 0] [0 .75 0] [0 0 .75] [.75 .75 0] [0 .75 .75] [.75 0 .75] };
else
    line_colors = {[0 0 0]};
end
acclim = [];
acctick = [];
acclim2D = [];
acclim3D = [];
cent_acctick = [];
nolatency = false;
figure_size = [500 400];

% unpack config
v2struct(cfg);

% subplot direction
ax1 = 1; ax2 = 2;
if strcmpi(figure_axis,'vertical')
    ax1 = 2; ax2 = 1;
end

% BACKWARDS COMPATIBILITY
if exist('one_two_tailed','var')
    error('The cfg.one_two_tailed field has been replaced by the cfg.tail field. Please replace cfg.one_two_tailed with cfg.tail using ''both'', ''left'' or ''right''. See help for further info.');
end

% where does this come from
if isfield(stats(1),'cfg')
    if isfield(stats(1).cfg,'startdir')
        startdir = stats(1).cfg.startdir;
    end
    if isfield(stats(1).cfg,'folder')
        folder = stats(1).cfg.folder;
    end
    % only plot the line itself as thick when no significance was computed
    if isfield(stats(1).cfg,'mpcompcor_method') && strcmpi(stats(1).cfg.mpcompcor_method,'none')
        cfg.plotsigline_method = 'follow';
    end
end

% set color-limits (z-axis) or y-limits
if isempty(cent_acctick)
    settings = stats(1).settings;
    if ~isfield(settings,'chance') % backwards compatibility
        if any(strcmpi(settings.measuremethod,{'hr-far','dprime','hr','far','mr','cr'})) || strcmpi(settings.measuremethod,'\muV') || ~isempty(strfind(settings.measuremethod,' difference')) || ~isempty(strfind(settings.measuremethod,' correlation')) || strcmpi(plot_model,'FEM')
            cent_acctick = 0;
        elseif strcmpi(settings.measuremethod,'AUC')
            cent_acctick = .5;
        else
            cent_acctick = 1/settings.nconds;
        end
    else
        cent_acctick = settings.chance;
    end
end
chance = cent_acctick;

% direction of y-axis
if isempty(inverty)
    if strcmpi(stats(1).settings.measuremethod,'\muV')
        inverty = true;
    else
        inverty = false;
    end
end

% set plottype
if any(size(stats(1).ClassOverTime)==1) || ploterp == true
    plottype = '2D'; %  used internally in this function
else
    plottype = '3D';
end
if strcmpi(plottype,'3D')
    singleplot = false;
end

% set line colors
if ~iscell(line_colors)
    for c=1:size(line_colors,1)
        cell_colors{c} = line_colors(c,:);
    end
    line_colors = cell_colors;
end
if numel(line_colors)<numel(stats) || isempty(line_colors)
    if numel(stats) > 1
        line_colors = {[.5 0 0] [0 .5 0] [0 0 .5] [.5 .5 0] [0 .5 .5] [.5 0 .5] [.75 0 0] [0 .75 0] [0 0 .75] [.75 .75 0] [0 .75 .75] [.75 0 .75] };
    else
        line_colors = {[0 0 0]};
    end
end

% determine which conditions to plot
if ~isempty(plot_order)
    for cPlot = 1:numel(plot_order)
        statindex = find(strcmpi(plot_order{cPlot},{stats(:).condname}));
        if isempty(statindex)
            statindex = find(strncmpi(plot_order{cPlot},{stats(:).condname},numel(plot_order{cPlot})));
            if isempty(statindex)
                error(['cannot find condition ' plot_order{cPlot} ' specified in cfg.plot_order']);
            end
        end
        if numel(statindex) > 1
            error(['cannot find a unique condition for the pattern ' plot_order{cPlot} ' specified in cfg.plot_order, remove cfg.plot_order to plot these graphs.']);
        end
        newstats(cPlot) = stats(statindex);
        new_line_colors{cPlot} = line_colors{statindex};
    end
    stats = newstats;
    line_colors = new_line_colors;
end

% which are the raw stats and which are the difstats? Only use the raw stats for y-limits.
rawstats = [];
rawchance = 0;
for cStats = 1:numel(stats)
    if isempty(strfind(stats(cStats).settings.measuremethod,' difference')) && isempty(strfind(stats(cStats).settings.measuremethod,' correlation'))
        rawstats = [rawstats cStats];
        settings = stats(cStats).settings;
        if ~isfield(settings,'chance') % backwards compatibility
            if any(strcmpi(settings.measuremethod,{'hr-far','dprime','hr','far','mr','cr'})) || strcmpi(settings.measuremethod,'\muV') || ~isempty(strfind(settings.measuremethod,' difference')) || ~isempty(strfind(settings.measuremethod,' correlation')) || strcmpi(plot_model,'FEM')
                rawchance = 0;
            elseif strcmpi(settings.measuremethod,'AUC')
                rawchance = .5;
            else
                rawchance = 1/settings.nconds;
            end
        else
            rawchance = stats(cStats).settings.chance;
        end
    end
end
difstats = setdiff(1:numel(stats),rawstats);
if ~isempty(difstats) && ~isempty(rawstats) && singleplot
    stats2useforlims = rawstats;
elseif isempty(difstats) || isempty(rawstats)
    stats2useforlims = 1:numel(stats);
else
    stats2useforlims = [];
end

% determine common accuracy limits
if isempty(acclim)
    eval(['acclim = acclim' plottype ';']);
end
if isempty(acclim) && ~isempty(stats2useforlims)
    mx = max(max(([stats(stats2useforlims).ClassOverTime])));
    mn = min(min(([stats(stats2useforlims).ClassOverTime])));
    if strcmpi(plottype,'2D') % this is a 2D plot
        shift = abs(diff([mn mx]))/10;
        acclim = [mn-shift mx+shift];
    else
        shift = abs(diff([mn mx]))/20;
        mx = max(abs([mx-chance chance-mn]));
        acclim = [-mx-shift mx+shift]+chance;
    end
end

% determine common acctick
if isempty(acctick) && ~isempty(acclim)
    if plotsubjects
        mx = max(acclim);
        mn = min(acclim);
        if strcmpi(plottype,'3D')
            acctick = abs(max(abs([chance-mn mx-chance])))-0.001;
        else
            acctick = abs(max(abs([chance-mn mx-chance])))/2;
        end
    else
        if strcmpi(stats(1).settings.measuremethod,'\muV')
            acctick = round(diff(acclim)/8);
            if acctick ==0
                acctick = 1;
            end
        else
            acctick = round(diff(acclim)/8,2);
        end
    end
end

% pack config with defaults
nameOfStruct2Update = 'cfg';
cfg = v2struct(nolatency,rawstats,rawchance,inverty,acclim,acctick,chance,cent_acctick,line_colors,ndec,plottype,singleplot,swapaxes,referenceline,nameOfStruct2Update);

% make figure?
if ~plotsubjects
    title_text = regexprep(regexprep(regexprep(folder,'\\','/'),regexprep(startdir,'\\','/'),''),'_',' ');
    if numel(stats) == 1
        title_text = title_text(1:find(title_text=='/',1,'last')-1);
    end
    if ~exist('fh','var')
        fh = figure('name',title_text);
    end
    % make sure all figures have the same size regardless of nr of subplots
    % and make sure they fit on the screen
    screensize = get(0,'screensize'); % e.g. 1920 * 1080
    if singleplot
        UL = screensize([3 4])-50; % subtract a little to be on the save side
    else
        UL = (screensize([3 4])-50)./[numSubplots(numel(stats),ax2) numSubplots(numel(stats),ax1)];
    end
    if any(UL>figure_size) % if the screen size is larger than the intended figure, take the intended figure size as leading
        UL=figure_size; % take this as default
    end
    po=get(fh,'position');
    if singleplot
        po(3:4)=UL;
    else
        po(3:4)=UL.*[numSubplots(numel(stats),ax2) numSubplots(numel(stats),ax1)];
    end
    po(1:2) = (screensize(3:4)-po(3:4))/2; po(logical([po(1:2)<100 0 0])) = round(po(logical([po(1:2)<100 0 0]))/4); % position in the center, push further to left / bottom if there is little space on horizontal or vertical axis axis
    set(fh,'position',po);
    set(fh,'color','w');
end

% main routine
if numel(stats)>1
    for cStats=1:numel(stats)
        disp(['plot ' num2str(cStats)]);
        if singleplot
            hold on;
            [map, H, cfg] = subplot_MVPA(cfg,stats(cStats),cStats, numel(stats));
            if isfield(H,'mainLine')
                legend_handle(cStats) = H.mainLine;
            elseif isfield(H,'dataLine')
                legend_handle(cStats) = H.dataLine;
            else
                error('huh? missing handle to plot legend!');
            end
            legend_text{cStats} = regexprep(regexprep(stats(cStats).condname,'_',' '),'-','-\n');
        else
            subplot(numSubplots(numel(stats),ax1),numSubplots(numel(stats),ax2),cStats);
            [map, ~, cfg] = subplot_MVPA(cfg,stats(cStats),cStats, numel(stats)); % all in the first color
            title(str2cell(regexprep(stats(cStats).condname,'_',' '),'-'),'FontSize',10);
        end
    end
    if singleplot
        legend boxoff;
        legend(legend_handle,legend_text,'FontSize',10);
        %
    end
else
    map = subplot_MVPA(cfg,stats);
    if ~plotsubjects
        title(str2cell(regexprep(stats.condname,'_',' '),'-'),'FontSize',10);
    end
end
if strcmpi(plottype,'3D')
    wraptext('IMPORTANT NOTE: A change was made to the plotting procedure of temporal generalization matrices and frequency plots in version 1.10 of ADAM. All uncorrected significant test points are now plotted as saturated points, regardless of the multiple comparison correction method. Cluster-based permutation corrected tests or FDR corrected tests are encircled by a a dark-red contour line (for above chance decoding) or dark-blue contour line (for below chance decoding). If no such line(s) appear(s), none of your tests survived multiple comparison correction.',80);
end

function [map, H, cfg] = subplot_MVPA(cfg,stats,cGraph,nGraph)
map = [];
if nargin<4
    nGraph = 1;
end
if nargin<3
    cGraph = 1;
end

% setting some graph defaults
trainlim = [];
testlim = [];
freqlim = [];
freqtick = [];
plot_model = [];
reduce_dims = [];
inverty = false;
downsamplefactor = 1;
smoothfactor = 1;
plotsigline_method = 'both';
splinefreq = [];
timetick = [];
acctick = [];
mpcompcor_method = 'uncorrected';
plotsubjects = false;
cluster_pval = .05;
indiv_pval = .05;
tail = 'both';

% then unpack cfgs to overwrite defaults, first original from stats, then the new one 
if isfield(stats,'cfg')
    oldcfg = stats.cfg;
    v2struct(oldcfg); % unpack the stats-specific cfg
    stats = rmfield(stats,'cfg');
end
v2struct(cfg);
if isempty(splinefreq)
    makespline = false;
else
    makespline = true;
end
% interpolation does not seem to work for 3D, just turn it off for now
if strcmpi(plottype,'3D')
    makespline = false;
end

% unpack stats
v2struct(stats);
settings = stats.settings; % little hardcoded hack because settings.m is apparently also a function

% now settings should be here, unpack these too
freqs = 0;
v2struct(settings);

% fill some empties
if isempty(freqtick)
    if max(freqlim) >= 60
        freqtick = 20;
    else
        freqtick = 10;
    end
end

% first a hack to change make sure that whatever is in time is expressed as ms
if mean(times{1}<10)
    times{1} = round(times{1} * 1000);
    if numel(times) > 1
        times{2} = round(times{2} * 1000);
    end
end

% determine axes
if strcmpi(reduce_dims,'avtrain') 
    xaxis = times{2};
elseif strcmpi(reduce_dims,'avtest') || strcmpi(reduce_dims,'avfreq')
    xaxis = times{1};
elseif strcmpi(dimord,'time_time')
    xaxis = times{1};
    yaxis = times{2};
elseif strcmpi(dimord,'freq_time')
    xaxis = times{1};
    yaxis=round(freqs);
end

% determine time tick
if isempty(timetick)
    timetickoptions = [5,10,25,50,100,250,500,750,1000,1250,1500,2000,2500,5000];
    timetick = timetickoptions(nearest(timetickoptions,(max(xaxis) - min(xaxis))/5));
end

% if time tick is smaller than sample duration, increase time tick to sample duration
if numel(xaxis)>1 && timetick < (xaxis(2)-xaxis(1))
    timetick = ceil((xaxis(2)-xaxis(1)));
end

% get x-axis and y-axis values
[dims] = regexp(dimord, '_', 'split');
ydim = dims{1};
xdim = dims{2}; % unused

% determine accuracy limits
if isempty(acclim)
    mx = max(max(([stats.ClassOverTime])));
    mn = min(min(([stats.ClassOverTime])));
    if strcmpi(plottype,'2D') % this is a 2D plot
        shift = abs(diff([mn mx]))/10;
        acclim = [mn-shift mx+shift];
    else
        shift = abs(diff([mn mx]))/20;
        mx = max(abs([mx-chance chance-mn]));
        acclim = [-mx-shift mx+shift]+chance;
    end
end

% determine acctick
if isempty(acctick)
    if plotsubjects
        mx = max(acclim);
        mn = min(acclim);
        if strcmpi(plottype,'3D')
            acctick = abs(max(abs([chance-mn mx-chance])))-0.001;
        else
            acctick = abs(max(abs([chance-mn mx-chance])))/2;
        end
    else
        if strcmpi(stats(1).settings.measuremethod,'\muV')
            acctick = round(diff(acclim)/8);
            if acctick == 0
                acctick = 1;
            end
        else
            acctick = round(diff(acclim)/8,2);
        end
    end
end
if acctick == 0
    acctick = .01;
end

% stuff particular to 2D and 3D plotting
if strcmpi(plottype,'2D')
    yaxis = sort(unique([cent_acctick:-acctick:min(acclim) cent_acctick:acctick:max(acclim)]));
    data = ClassOverTime;
    stdData = StdError;
    % some downsampling on 2D
    if ~isempty(downsamplefactor) && downsamplefactor > 0
        xaxis = downsample(xaxis,downsamplefactor);
        data = downsample(data,downsamplefactor);
        if ~isempty(StdError)
            stdData = downsample(stdData,downsamplefactor);
        end
        if ~isempty(pVals)
            pVals = downsample(pVals,downsamplefactor);
        end
    end
    % some smoothing on 2D using spline
    if makespline
       data = compute_spline_on_classify(data,xaxis',splinefreq);
       if ~isempty(stdData)
           stdData = compute_spline_on_classify(stdData,xaxis',splinefreq);
       end
    end
else
    zaxis = sort(unique([cent_acctick:-acctick:min(acclim) cent_acctick:acctick:max(acclim)]));
    data = ClassOverTime;
end

% set ticks for x-axis and y-axis
xticks = timetick;
if strcmpi(plottype,'3D')
    if strcmpi(ydim,'freq')
        yticks = freqtick;
    else
        yticks = xticks;
    end
else
    yticks = acctick;
end

% some smoothing on 3D, this may neeed fixing?
if makespline && strcmpi(plottype,'3D')
    xaxis = spline(1:numel(xaxis),xaxis,linspace(1, numel(xaxis), round(numel(xaxis)/smoothfactor))); 
    yaxis = spline(1:numel(yaxis),yaxis,linspace(1, numel(yaxis), round(numel(yaxis)/smoothfactor))); 
end

% make a timeline that has 0 as zero-point and makes steps of xticks
if min(xaxis) < 0 && max(xaxis) > 0
    findticks = sort(unique([0:-xticks:min(xaxis) 0:xticks:max(xaxis)]));
else
    findticks = sort(unique(min(xaxis):xticks:max(xaxis)));
end
indx = [];
for tick = findticks
    indx = [indx nearest(xaxis,tick)];
end

% do the same for y-axis
if strcmpi(ydim,'freq')
    findticks = yticks:yticks:max(yaxis);
else
    if min(yaxis) < 0 && max(yaxis) > 0
        findticks = sort(unique([0:-yticks:min(yaxis) 0:yticks:max(yaxis)]));
    else
        findticks = sort(unique(min(yaxis):yticks:max(yaxis)));
    end
end
indy = [];
for tick = findticks
    indy = [indy nearest(yaxis,tick)];
end

% plot
if plotsubjects
    fontsize = 10;
else
    fontsize = 14;
end
if strcmpi(plottype,'2D')
    % if we are plotting dif stats together with raw stats, put them on a second axis
    if ~isempty(rawstats) && (~isempty(strfind(measuremethod,' difference')) || ~isempty(strfind(measuremethod,' correlation'))) && singleplot
        yaxis = yaxis - rawchance; % a little hack to shift stuff up and down
        data = data + rawchance;
    end
    colormap('default');
    if isempty(StdError)
        H.dataLine = plot(data,'Color',line_colors{cGraph});
    else
        % slightly lighter version of the original color
        H = shadedErrorBar(1:numel(data),data,stdData,{'Color',line_colors{cGraph} + (1 - line_colors{cGraph})/2,'MarkerFaceColor',[1 1 0]},.1);
    end
    hold on;
    % plot horizontal line on zero
    plot([1,numel(data)],[chance,chance],'k--');
    % plot vertical line on zero
    plot([nearest(xaxis,0),nearest(xaxis,0)],[acclim(1),acclim(2)],'k--');
    
    % plot help line
    if ~isempty(referenceline)
        for c = 1:numel(referenceline)
            plot([nearest(xaxis,referenceline(c)),nearest(xaxis,referenceline(c))],[acclim(1),acclim(2)],'k--');
        end
    end
    
    % plot significant time points
    if ~isempty(pVals)
        sigdata = data;
        if strcmpi(plotsigline_method,'straight') || strcmpi(plotsigline_method,'both') 
            if ~singleplot elevate = 1; else elevate = (nGraph-cGraph)+.5; end
            if inverty
                elevate = max(acclim) - (diff(acclim)/80)*elevate;
            else
                elevate = min(acclim) + (diff(acclim)/80)*elevate;
            end
            sigdata(1:numel(sigdata)) = elevate;
            sigdata(pVals>=indiv_pval) = NaN;
            if isnumeric(line_colors{cGraph})
                H.bottomLine=plot(1:numel(sigdata),sigdata,'Color',line_colors{cGraph},'LineWidth',3); % sigline below graph
            else
                H.bottomLine=plot(1:numel(sigdata),sigdata,line_colors{cGraph},'LineWidth',2); % sigline below graph
            end
        end
        sigdata = data;
        if strcmpi(plotsigline_method,'follow') || strcmpi(plotsigline_method,'both')
            sigdata(pVals>=indiv_pval) = NaN;
            if isnumeric(line_colors{cGraph})
                H.mainLine=plot(1:numel(sigdata),sigdata,'Color',line_colors{cGraph},'LineWidth',3); % sigline on graph
            else
                H.mainLine=plot(1:numel(sigdata),sigdata,line_colors{cGraph},'LineWidth',3); % sigline on graph
            end
        end
        % plot onset latency (in the same color as the graph)
        if exist('latencies','var') && ~isempty(latencies) && ~nolatency
            onset = latencies.GA;
            onsetindex = nearest(xaxis,onset);
            % plot a circle on the onset in the line graph
            if strcmpi(plotsigline_method,'follow') || strcmpi(plotsigline_method,'both')
                plot(onsetindex,sigdata(onsetindex),'o','Color',line_colors{cGraph});
            end
            % plot a circle at the onset near the x-axis on the significance line
            if strcmpi(plotsigline_method,'straight') || strcmpi(plotsigline_method,'both')
                plot(onsetindex,elevate,'o','Color',line_colors{cGraph});
            end
            % plot a vertical line at the onset between the graph and the significance line
            if strcmpi(plotsigline_method,'both')
                plot([onsetindex,onsetindex],[elevate,sigdata(onsetindex)],'--','Color',line_colors{cGraph});
            end
        end
        if strcmpi(tail,'both'); tail = '2'; end
        if ~plotsubjects
            if strcmpi(mpcompcor_method,'uncorrected')
                h_legend = legend(H.mainLine,[' p < ' num2str(indiv_pval) ' (uncorrected, ' tail '-sided)']); % ,'Location','SouthEast'
            elseif strcmpi(mpcompcor_method,'cluster_based')
                h_legend = legend(H.mainLine,[' p < ' num2str(cluster_pval) ' (cluster based, ' tail '-sided)']);
            elseif strcmpi(mpcompcor_method,'fdr')
                h_legend = legend(H.mainLine,[' p < ' num2str(cluster_pval) ' (FDR, ' tail '-sided)']);
            end
            if ~strcmpi(mpcompcor_method,'none')
                legend boxoff;
                set(h_legend,'FontSize',12);
            end
        end
    else
        if strcmpi(plotsigline_method,'follow') || strcmpi(plotsigline_method,'both')
            sigdata = data;
            if isnumeric(line_colors{cGraph})
                H.mainLine=plot(1:numel(sigdata),sigdata,'Color',line_colors{cGraph},'LineWidth',3); % sigline on graph
            else
                H.mainLine=plot(1:numel(sigdata),sigdata,line_colors{cGraph},'LineWidth',3); % sigline on graph
            end
        end
    end
    if unique(numel(acclim)) == 2
        ylim(acclim);
    end
    xlim([1 numel(data)]);
    if strcmpi(reduce_dims,'avtrain')
        xlabel('test time in ms','FontSize',fontsize);
    elseif strcmpi(reduce_dims,'avtest')
        xlabel('train time in ms','FontSize',fontsize);
    else
        xlabel('time in ms','FontSize',fontsize);
    end
    % if we are plotting dif stats together with raw stats, put them on a second axis
    if ~isempty(rawstats) && (~isempty(strfind(measuremethod,' difference')) || ~isempty(strfind(measuremethod,' correlation'))) && singleplot
        ax = axes('YLim',get(gca,'YLim'),'YTick',get(gca,'YTick'),'YTickLabel',get(gca,'YTickLabel'),'Position',get(gca,'Position'),'YAxisLocation','right','YColor',line_colors{cGraph});
        ylabel(measuremethod,'FontSize',fontsize,'Color',line_colors{cGraph});
    else
        ax = gca;
        set(ax,'YTick',yaxis);
        ylabel(measuremethod,'FontSize',fontsize);
    end
    ticklabel = regexp(deblank(sprintf(['%0.' num2str(ndec) 'f '],yaxis)),' ','split');
    if chance ~= 0 % create labels containing equal character counts when centered on some non-zero value
        ticklabel((yaxis == chance)) = {'chance'}; % say "chance".
    end
    set(ax,'YTickLabel',ticklabel);
    hold off;
else
    % determine significant time points
    origdata = data;
    if ~isempty(pVals) && ~strcmpi(mpcompcor_method,'none')
        if exist('pValsUncorrected','Var')
            [data, map] = showstatsTFR(data,pValsUncorrected,acclim);
        else
            [data, map] = showstatsTFR(data,pVals,acclim);
        end
    else
        cmap  = brewermap([],'*RdBu');
        colormap(cmap);
    end
    
    % some smoothing on 3D
    if makespline
        if ~ismatrix(data) % DOUBLE CHECK WHETHER THIS IS OK
            [X,Y,Z] = meshgrid(1:size(data,2),1:size(data,1),1:size(data,3));
            [XX,YY,ZZ] = meshgrid(linspace(1,size(data,2),round(size(data,2)/smoothfactor)),linspace(1,size(data,1),round(size(data,1)/smoothfactor)),1:size(data,3));
            data = interp3(X,Y,Z,data,XX,YY,ZZ);
        else
            % this cannot happen because we are in 3D plotting part right?
            [X,Y] = meshgrid(1:size(data,2),1:size(data,1));
            [XX,YY] = meshgrid(linspace(1,size(data,2),round(size(data,2)/smoothfactor)),linspace(1,size(data,1),round(size(data,1)/smoothfactor)));
            data = uint8(interp2(X,Y,double(data),XX,YY));
        end
    end
    if strcmpi(ydim,'freq')
        ylegend = 'frequency in Hz';
        xlegend = 'time in ms';
    else
        ylegend = 'testing time in ms';
        xlegend = 'training time in ms';
    end
    if swapaxes
        origdata = permute(origdata,[2 1 3]); 
        data = permute(data,[2 1 3]);
        pVals = permute(pVals,[2 1 3]);
        [xaxis,yaxis] = swapvars(xaxis,yaxis);
        [xticks,yticks] = swapvars(xticks,yticks);
        [xlegend,ylegend] = swapvars(xlegend,ylegend);
        [indx,indy] = swapvars(indx,indy);
    end
    imagesc(data);
    caxis(acclim);
    set(gca,'YDir','normal'); % set the y-axis right
    
    % plot contour lines of significant values
    if ~isempty(pVals) && ~strcmpi(mpcompcor_method,'none') && ~strcmpi(mpcompcor_method,'uncorrected')
        binary = zeros(size(pVals));
        binary(pVals <.05) = 1;
        binary(origdata<chance) = -binary(origdata<chance);
        % make correctly scaled matrix
        contourmatrix = ones(size(pVals))*chance;
        contourmatrix(binary<0) = acclim(1) - 0.1;
        contourmatrix(binary>0) = acclim(2) + 0.1;
        hold on;
        contour(contourmatrix,acclim,'LineWidth',2);
    end

    % plot some help lines
    if ~isempty(referenceline)
        hold on;
        for c = 1:numel(referenceline)
            timeinms = referenceline(c);
            plot([nearest(xaxis,timeinms),nearest(xaxis,timeinms)],[nearest(yaxis,min(yaxis)),nearest(yaxis,max(yaxis))],'k--');
            plot([nearest(xaxis,min(xaxis)),nearest(xaxis,max(xaxis))],[nearest(yaxis,timeinms),nearest(yaxis,timeinms)],'k--');
        end
        % plot([nearest(xaxis,min(xaxis)),nearest(xaxis,max(xaxis))],[nearest(yaxis,min(yaxis)),nearest(yaxis,max(yaxis))],'k--');
    end
    
    % set ticks on color bar
    hcb=colorbar;
    Ylabel = regexp(deblank(sprintf(['%0.' num2str(ndec) 'f '],zaxis)),' ','split');
    if chance ~= 0 % create labels containing equal character counts when centered on some non-zero value
        Ylabel((zaxis == chance)) = {'chance'}; % say "chance".
    end
    set(hcb,'YTick',zaxis,'YTickLabel',Ylabel);
    %ylabel(hcb,regexprep(measuremethod,'_',' ')); % add measuremethod to colorbar
    title(hcb,str2cell(regexprep(measuremethod,'_',' '),' '),'FontSize',10); % you can also put it above the color bar if you prefer
    xlabel(xlegend,'FontSize',fontsize);
    ylabel(ylegend,'FontSize',fontsize);
    set(gca,'YTick',indy);
    roundto = yticks;
    set(gca,'YTickLabel',num2cell(int64(round(yaxis(indy)/roundto)*roundto))); % convert to int64 to prevent -0 at 0-axis
end
% set ticks on horizontal axis
roundto = xticks;
set(gca,'XTickLabel',num2cell(int64(round(xaxis(indx)/roundto)*roundto)));
set(gca,'XTick',indx);
%set(gca,'XTickLabel',num2cell(int64(round(xaxis(indx)))));
set(gca,'FontSize',fontsize);
set(gca,'color','none');
if numel(xaxis) == numel(yaxis) || ~strcmpi(dimord,'time_time') || strcmpi(plottype,'2D')  
    axis square;
else
    maxaspect = max([numel(xaxis) numel(yaxis)]);
    pbaspect([numel(xaxis)/maxaspect numel(yaxis)/maxaspect 1]);
end
if inverty
    set(gca,'YDir','reverse');
end
if plotsubjects && strcmpi(plottype,'2D')
    sameaxes('xyzc',gcf());
end

% invent handle if it does not exist
if ~exist('H')
    H = [];
end
