<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Index for Directory NoiseTools</title>
  <meta name="keywords" content="NoiseTools">
  <meta name="description" content="Index for Directory NoiseTools">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for NoiseTools&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>

<h1>Index for NoiseTools</h1>

<h2>Matlab files in this directory:</h2>
<table>
<tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_banner.html">nt_banner</a></td><td>h=nt_banner(text,varargin) - annotate with text at head of figure </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_bias_cluster.html">nt_bias_cluster</a></td><td>[c0,c1,A,todss,pwr0,pwr1]=nt_bias_cluster(x,dsr,flags) - cluster covariance </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_bias_fft.html">nt_bias_fft</a></td><td>[c0,c1]=nt_bias_fft(x,freq,nfft) - covariance with and w/o filter bias </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_bias_filter.html">nt_bias_filter</a></td><td>[c0,c1]=nt_bias_filter(x,B,A) - covariance with and w/o filter bias </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_bsmean.html">nt_bsmean</a></td><td>[mn,sd,all]=nt_bsmean(x,N,w) - calculate mean, estimate sd using bootstrap </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_bsmean_diff.html">nt_bsmean_diff</a></td><td>[mn,sd]=nt_bsmean_diff(x1,x2,N) - calculate mean, estimate sd using bootstrap </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_bsplot.html">nt_bsplot</a></td><td>nt_bsplot(x,sds,style,abscissa,zeroflag,rmsflag) - plot average with bootstrap standard deviation </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_bsplot2.html">nt_bsplot2</a></td><td>nt_bsplot(x,percentile,style,abscissa,zeroflag,rmsflag) - plot average with confidence interval </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_bsplot_diff.html">nt_bsplot_diff</a></td><td>nt_bsplot_diff(x,y,sds,style,abscissa,zeroflag,rmsflag) - plot average difference with bootstrap standard deviation </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_bsrms.html">nt_bsrms</a></td><td>[rms,sd,all]=nt_bsrms(x,N,w) - calculate rms, estimate sd using bootstrap </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_bsrmsmean.html">nt_bsrmsmean</a></td><td>[r,sd,all]=ft_bsrmsmean(x,N) - rms over channels of mean over trials, estimate sd using bootstrap </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_cca.html">nt_cca</a></td><td>[A,B,R]=nt_cca(x,y,shifts,C,m,thresh) - canonical correlation </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_cca_crossvalidate.html">nt_cca_crossvalidate</a></td><td>[AA,BB,RR,SD]=nt_cca_crossvalidate(xx,yy,shifts,doSurrogate) - CCA with cross-validation </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_cluster1D.html">nt_cluster1D</a></td><td>[C,A,score]=nt_cluster1D_b(x) - cluster 1D data into 2 clusters </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_cluster_jd.html">nt_cluster_jd</a></td><td>[IDX,todss,SCORE,COVS]=nt_cluster_jd(x,dsr,smooth,flags,init,verbose) - cluster with joint diagonalization </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_cov.html">nt_cov</a></td><td>[c,tw]=nt_cov(x,shifts,w) - time shift covariance </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_cov2.html">nt_cov2</a></td><td>[c,tw]=nt_cov2(x,w) - weighted covariance </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_cov_lags.html">nt_cov_lags</a></td><td>[C,tw,m]=nt_cov_lags(x,y,shifts) - covariance of [x,y] with lags </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_dataview.html">nt_dataview</a></td><td>[p,data]=nt_dataview(data,p) - view data sets </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_deboing.html">nt_deboing</a></td><td>y=nt_deboing(x,events) - fit, remove ringing associated with events </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_demean.html">nt_demean</a></td><td>[y,mn]=nt_demean(x,w) - remove weighted mean over cols </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_demean2.html">nt_demean2</a></td><td>y=nt_demean2(x,w) - remove mean of each row and page </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_destep.html">nt_destep</a></td><td>[y,stepList]=nt_destep(x,thresh,guard,depth,minstep) - remove step glitch from MEG data </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_detrend.html">nt_detrend</a></td><td>[y,w,r]=nt_detrend(x,order,w,basis,thresh,niter) - robustly remove trend </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_dft_filter.html">nt_dft_filter</a></td><td>y=nt_dft_filter(x,transfer,N) - apply filter using DFT </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_dprime.html">nt_dprime</a></td><td>[d,err_rate,perm,area_roc,roc]=nt_dprime(x,y,jd_flag) - calculate d' (discriminability) of two distributions </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_dsample.html">nt_dsample</a></td><td>y=nt_dsample(x,factor) - downsample by averaging neighboring samples </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_dss0.html">nt_dss0</a></td><td>[todss,pwr1,pwr2]=nt_dss0(c0,c1,keep1,keep2) - dss from covariance </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_dss1.html">nt_dss1</a></td><td>[todss,pwr0,pwr1]=nt_dss1(x,w,keep1,keep2) - evoked-biased DSS denoising </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_dss_repeat_cluster.html">nt_dss_repeat_cluster</a></td><td>y=nt_dss_repeat_cluster(x,nkeep,cluster_size) - dss within clusters </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_epochify.html">nt_epochify</a></td><td>y=nt_epochify(x,tidx,bounds) - extract epochs based on trigger indices </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_filter_peak.html">nt_filter_peak</a></td><td>[B,A] = nt_filter_peak(Wo,Q) - second order resonator filter </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_find_bad_channels.html">nt_find_bad_channels</a></td><td>[iBad,toGood]=nt_find_bad_channels(x,proportion,thresh1,thresh2,thresh3) - find bad channels </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_find_outlier_trials.html">nt_find_outlier_trials</a></td><td>[idx,d,mn,idx_unsorted]=nt_find_outlier_trials(x,criterion,plot,regress_flag) - find outlier trials </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_fixsign.html">nt_fixsign</a></td><td>y=nt_fixsign(x) - flip signs to maximize inter-component correlation </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_fold.html">nt_fold</a></td><td>y=fold(x,epochsize) - fold 2D to 3D </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_greetings.html">nt_greetings</a></td><td>nt_greetings - display message the first time the toolbox is used </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_growmask.html">nt_growmask</a></td><td>ww=nt_growmask(w,margin) - widen mask </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_idx.html">nt_idx</a></td><td>i=nt_idx(x,scale,i) - index a data matrix </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_idx_disp.html">nt_idx_disp</a></td><td>nt_idx_disp(name,field,explainflag) - display contents of index file </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_imagescc.html">nt_imagescc</a></td><td>nt_imagescc - plot image with symmetric scaling </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_index.html">nt_index</a></td><td>[status,p]=nt_index(name,p,forceUpdate) - index data files & directories </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_inpaint.html">nt_inpaint</a></td><td>function y=nt_inpaint(x,w) - weighted interpolation based on correlation structure </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_interpolate_bad_channels.html">nt_interpolate_bad_channels</a></td><td>y=interpolate_bad_channels(x,iBad,coordinates,n) - interpolate bad channels from good </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_iplot.html">nt_iplot</a></td><td>[hh,ii]=nt_iplot(fname) - plot data file based on index </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_linecolors.html">nt_linecolors</a></td><td>nt_colorlines(h,permutation) - apply different colors to lines of plot </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_linestyles.html">nt_linestyles</a></td><td>nt_stylelines(h,property,values) - apply different styles to lines of plot </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_lower_to_full.html">nt_lower_to_full</a></td><td>b=nt_lower_to_full(a,ind) - transform lower diagonal to full  covariance </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_mark.html">nt_mark</a></td><td>nt_mark(idx,labels,line_params,text_params) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_mat2trial.html">nt_mat2trial</a></td><td>[y]=nt_trial2mat(x) - convert 3D matrix to trial cell array </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_mcca.html">nt_mcca</a></td><td>[A,score,AA]=nt_mcca(C,N) - multiple cca </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_mmat.html">nt_mmat</a></td><td>y=nt_mmat(x,m) -  matrix multiplication (with convolution) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_mmx.html">nt_mmx</a></td><td>[y,abscissa]=nt_mmx(x, N) - calculate min-max pairs </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_morton.html">nt_morton</a></td><td>[iMorton,toMorton]=nt_morton(nrows,ncols) - indices for Morton scan of image </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_multishift.html">nt_multishift</a></td><td>z=nt_multishift(x,shifts,amplitudes) - apply multiple shifts to matrix </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_multismooth.html">nt_multismooth</a></td><td>z=nt_multismooth(x,smooth,alignment) - apply multiple smoothing kernels </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_narrowband_scan.html">nt_narrowband_scan</a></td><td>A=nt_narrowband_scan(x,freqs,sr,Q,plotflag) - scan for narrowband components using DSS </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_normcol.html">nt_normcol</a></td><td>[y,norm]=nt_normcol(x,w) - normalize each column so its weighted msq is 1 </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_normpage.html">nt_normpage</a></td><td>y=nt_normpage(x,w) - normalize each page so its weighted msq is 1 </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_normpagecol.html">nt_normpagecol</a></td><td>y=nt_normpagecol(x,w) - normalize each column of each page so its weighted msq is 1 </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_normrow.html">nt_normrow</a></td><td>y=nt_normcol(x) - normalize each row so its msq is 1 </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_outliers.html">nt_outliers</a></td><td>[w,y]=nt_outliers(x,w,thresh,niter) - detect outliers based on weighted correlation structure </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_pca.html">nt_pca</a></td><td>[z,idx]=nt_pca(x,shifts,nkeep,threshold,w) - time-shift pca </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_pca0.html">nt_pca0</a></td><td>[topcs,pwr,y]=nt_pca0(x,shifts,nkeep,threshold,w) - time-shift pca </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_pca_kmeans.html">nt_pca_kmeans</a></td><td>[topcs,pwr]=nt_pca_kmeans(x,nkeep) - PCA preceded by kmeans for speed </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_pcarot.html">nt_pcarot</a></td><td>[topcs,eigenvalues]=pcarot(cov,nkeep,threshold,N) - PCA matrix from covariance </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_peaksign.html">nt_peaksign</a></td><td>sgn=peaksign(x,dim) - sign of largest extremum </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_phase_scramble.html">nt_phase_scramble</a></td><td>y=nt_phase_scramble(x) - scramble time but preserve autocorrelation </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_plot_mmx.html">nt_plot_mmx</a></td><td>nt_plot_mmx - plot data using min-max pairs </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_proximity.html">nt_proximity</a></td><td>[closest,d]=nt_proximity(coordinates,N) - distance to neighboring channels </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_qca.html">nt_qca</a></td><td>[squares,quads,D]=nt_qca(x,npcs,nsmooth,nquads) - maximize induced power using quadratic component analysis </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_qca0.html">nt_qca0</a></td><td>[tosquares,quads,D]=nt_qca0(x,npcs,nsmooth,nquads) - maximize induced power using quadratic component analysis </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_qca02.html">nt_qca02</a></td><td>[tosquare,quad,tosquare2,quad2,D]=nt_qca02(x,npcs,nsmooth) - maximize induced power using quadratic component analysis </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_qca2.html">nt_qca2</a></td><td>[square,quad,square2,quad2,D]=nt_qca(x,npcs,nsmooth) - maximize induced power using quadratic component analysis </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_qpca.html">nt_qpca</a></td><td>[squares,quads]=nt_qpca(x,npcs,nsmooth,nquads) - quadratic PCA </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_qpca0.html">nt_qpca0</a></td><td>[tosquares,quads,D]=nt_qpca0(x,npcs,nsmooth,nquads) - quadratic PCA </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_quad2square.html">nt_quad2square</a></td><td>[tosquare,D]=nt_quad2square(toquad,order) - quadratic to squared linear component </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_read_data.html">nt_read_data</a></td><td>[p,data]=nt_read_data(fname,flag) - read data from file </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_read_header.html">nt_read_header</a></td><td>[h,readwith]=nt_read_header(fname,flag) - read data from file </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_regcov.html">nt_regcov</a></td><td>r=nt_regcov(cxy,cyy,keep,threshold) - regression matrix from cross covariance </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_regw.html">nt_regw</a></td><td>[b,z]=nt_regw(y,x,w) - weighted regression </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_relshift.html">nt_relshift</a></td><td>[xx,yy]=nt_relshift(x,y,shift,flag) - delay x relative to y </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_rereference.html">nt_rereference</a></td><td>[y,mn]=nt_rereference(x,thresh,w,factor) - rereference by subtracting robust mean </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_resample.html">nt_resample</a></td><td>RESAMPLE  Change the sampling rate of a signal. </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_resample_interp.html">nt_resample_interp</a></td><td>y=nt_resample_interp(x,R,method) - resample with arbitrary ratio </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_rms.html">nt_rms</a></td><td>RMS - Root-mean-square </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_same_clim.html">nt_same_clim</a></td><td>nt_same_clim(h) - harmonize color limits of plots within figure </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_sgram.html">nt_sgram</a></td><td>[s,f,t]=nt_sgram(x,window,noverlap,nfft,sr,flags) - spectrogram </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_smooth.html">nt_smooth</a></td><td>y=nt_smooth(x,T,nIterations,nodelayflag) - smooth by convolution with square window </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_sns.html">nt_sns</a></td><td>y=nt_sns(x,nneigbors,skip,w) - sensor noise suppression </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_sns0.html">nt_sns0</a></td><td>r=nt_sns0(c,nneigbors,skip,wc) - sensor noise suppression </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_sns1.html">nt_sns1</a></td><td>y=nt_sns1(x,nneigbors,skip,w,threshold) - sensor noise suppression </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_sns_cluster.html">nt_sns_cluster</a></td><td>y=nt_sns_cluster(x,nneigbors,cluster_size) - sensor noise suppression within clusters </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_sparse_filter.html">nt_sparse_filter</a></td><td>y=nt_sparse_filter(x,T,A) - convolve multichannel data with sparse impulse response </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_spect_plot.html">nt_spect_plot</a></td><td>nt_spect_plot - plot power spectrum </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_spect_plot2.html">nt_spect_plot2</a></td><td>nt_spect_plot2 - plot power spectrum </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_split.html">nt_split</a></td><td>[idx,score_vector,score]=nt_split(x,depth,thresh,guard,minstep) - split time series into intervals </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_split_jd.html">nt_split_jd</a></td><td>[idx,score_vector,todss]=nt_split_dss(x,thresh,depth) - segmentation based on joint diagonalization </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_squeeze_all.html">nt_squeeze_all</a></td><td>y=nt_squeeze_all(x) - squeeze structs and cell arrays </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_star.html">nt_star</a></td><td>[y,w,ww]=nt_star(x,thresh,closest,depth) - sensor noise suppression </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_star2.html">nt_star2</a></td><td>[y,w,ww]=nt_star2(x,thresh,closest,w) - sensor noise suppression </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_statmatrix.html">nt_statmatrix</a></td><td>stats=nt_statMatrix(x,plot_params) - calculate statistics arrays for each dim of matrix </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_test.html">nt_test</a></td><td> </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_topoplot.html">nt_topoplot</a></td><td>nt_topoplot(cfg,data) - simple topoplot </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_trial2mat.html">nt_trial2mat</a></td><td>[y,w]=nt_trial2mat(x,max_nsamples) - convert trial cell array to 3D matrix </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_tsr.html">nt_tsr</a></td><td>[y,idx,w]=nt_tsr(x,ref,shifts,wx,wref,keep,thresh) - time-shift regression (TSPCA) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_tsr_nodemean.html">nt_tsr_nodemean</a></td><td>[y,idx,w]=nt_tsr_nodemean(x,ref,shifts,wx,wref,keep,thresh) - time-shift regression (TSPCA) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_tsregress.html">nt_tsregress</a></td><td>[z,idx]=nt_tsregress(x,y,shifts,xw,yw,keep,threshold) - time-shift regression </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_tsxcov.html">nt_tsxcov</a></td><td>[c,tw]=nt_tsxcov(x,y,shifts,w) - cross-covariance of X and time-shifted Y </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_unfold.html">nt_unfold</a></td><td>y=nt_fold(x) - unfold 3D to 2D </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_unique.html">nt_unique</a></td><td>[C,IA,IC,N] = nt_unique(A, varargin) - unique with counts </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_vecadd.html">nt_vecadd</a></td><td>y=nt_vecadd(x,v) - add vector to all rows or columns of matrix </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_vecmult.html">nt_vecmult</a></td><td>y=nt_vecmult(x,v) - multiply all rows or columns of matrix by vector </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_version.html">nt_version</a></td><td> </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_video_sns.html">nt_video_sns</a></td><td>y=nt_video_sns(x,nneighbors) - apply SNS locally </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_whiten.html">nt_whiten</a></td><td>[A,y]=nt_whiten(x,N) - whiten spectrally using pca </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_whoss.html">nt_whoss</a></td><td>size=nt_whoss - total Gbytes used by variables </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_wmean.html">nt_wmean</a></td><td>y=nt_wmean(x,w,dim) - weighted average </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_wpwr.html">nt_wpwr</a></td><td>[y,tweight]=nt_wpwr(x,w) - weighted power </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_xcov.html">nt_xcov</a></td><td>[c,tw]=nt_xcov(x,y,shifts,w) - cross-covariance of X and time-shifted Y </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_xprod.html">nt_xprod</a></td><td>[y,ind]=nt_xprod(x,flag,dsratio,normrow_flag) - form all crossproducts </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_xprod2.html">nt_xprod2</a></td><td>[y,ind]=nt_xprod(x1,x2,dsratio) - form all crossproducts </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="nt_xxcorr.html">nt_xxcorr</a></td><td>[C,idx]=nt_xxcorr(A,B,MAXLAG) - true unbiased cross-correlation </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="zz_package.html">zz_package</a></td><td> </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="zz_upload_data.html">zz_upload_data</a></td><td> </td></tr></table>


<h2>Subsequent directories:</h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li>COMPAT</li><li>DATA</li><li>EXAMPLES</li><li>JUNK</li><li>PACKAGE</li><li><a href="TEST/index.html">TEST</a></li><li>WEB</li><li>doc</li><li><a href="private/index.html">private</a></li></ul>

<hr><address>Generated on Tue 09-Oct-2018 10:58:04 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>